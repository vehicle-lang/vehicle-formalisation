{-# OPTIONS --postfix-projections #-}

module NormalisationCorrect where

open import Level using (0‚Ñì; suc)

open import Data.Bool using (not; _‚àß_; _‚à®_; true; false)
                   renaming (Bool to ùîπ; if_then_else_ to if·µá_then_else_)
open import Data.Fin using (Fin)
open import Data.Nat using (‚Ñï)
open import Data.Product using (_√ó_; _,_; proj‚ÇÅ; proj‚ÇÇ)
open import Data.Rational using (‚Ñö; _+_; _*_; _‚â§·µá_; _‚âü_)
open import Data.Rational.Properties using (*-identityÀ°)
open import Data.Unit using (‚ä§; tt)

open import Relation.Binary.PropositionalEquality using (_‚â°_; refl; trans; cong; sym; cong‚ÇÇ)

open import MiniVehicle hiding (_‚áí·µ£_)
open import NormalisedExpr
open import Normalisation

------------------------------------------------------------------------------
record World : Set where
  field
    ctxt : LinVarCtxt
    env  : Env ctxt
open World

-- World morphisms extend the context whilst making sure that the
-- environment is preserved.
record _‚áíw_ (w‚ÇÅ w‚ÇÇ : World) : Set where
  field
    ren   : w‚ÇÅ .ctxt ‚áí·µ£ w‚ÇÇ .ctxt
    presv : ‚àÄ x ‚Üí w‚ÇÅ .env (ren x) ‚â° w‚ÇÇ .env x
open _‚áíw_

id-w : ‚àÄ {w} ‚Üí w ‚áíw w
id-w .ren x = x
id-w .presv x = refl

_‚àòw_ : ‚àÄ {w‚ÇÅ w‚ÇÇ w‚ÇÉ} ‚Üí w‚ÇÇ ‚áíw w‚ÇÉ ‚Üí w‚ÇÅ ‚áíw w‚ÇÇ ‚Üí w‚ÇÅ ‚áíw w‚ÇÉ
(f ‚àòw g) .ren x = g .ren (f .ren x)
(f ‚àòw g) .presv x = trans (g .presv (f .ren x)) (f .presv x)

-- FIXME: move to NormalisationExpr
extend-env : ‚àÄ {Œî} ‚Üí Env Œî ‚Üí ‚Ñö ‚Üí Env (Œî ,‚àô)
extend-env Œ∑ q zero     = q
extend-env Œ∑ q (succ x) = Œ∑ x

extend-w : World ‚Üí ‚Ñö ‚Üí World
extend-w w q .ctxt = w .ctxt ,‚àô
extend-w w q .env = extend-env (w .env) q

under-w : ‚àÄ {w‚ÇÅ w‚ÇÇ q} ‚Üí (w‚ÇÅ ‚áíw w‚ÇÇ) ‚Üí (extend-w w‚ÇÅ q ‚áíw extend-w w‚ÇÇ q)
under-w œÅ .ren = NormalisedExpr.under (œÅ .ren)
under-w œÅ .presv zero = refl
under-w œÅ .presv (succ x) = œÅ .presv x

wk-w : ‚àÄ {w q} ‚Üí extend-w w q ‚áíw w
wk-w .ren = succ
wk-w .presv x = refl

------------------------------------------------------------------------------
-- Our category of related interpretations
record WRel : Set‚ÇÅ where
  -- no-eta-equality
  field
    Left  : Set
    Right : Syn
    rel   : (w : World) ‚Üí Left ‚Üí Right .Carrier (w .ctxt) ‚Üí Set
    ext   : ‚àÄ {w w'} (œÅ : w' ‚áíw w) a b ‚Üí rel w a b ‚Üí rel w' a (Right .rename (œÅ .ren) b)
open WRel

record _===>_ (X Y : WRel) : Set where
  field
    left  : X .Left ‚Üí Y .Left
    right : X .Right ==> Y .Right
    rel-mor   : ‚àÄ w lx rx ‚Üí X .rel w lx rx ‚Üí Y .rel w (left lx) (right .mor rx)
open _===>_

------------------------------------------------------------------------------
-- Composition

_‚àòR_ : ‚àÄ {X Y Z} ‚Üí (Y ===> Z) ‚Üí (X ===> Y) ‚Üí (X ===> Z)
(f ‚àòR g) .left x = f .left (g .left x)
(f ‚àòR g) .right = f .right ‚àòS g .right
(f ‚àòR g) .rel-mor w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ = f .rel-mor w _ _ (g .rel-mor w _ _ r-x‚ÇÅx‚ÇÇ)

‚ü¶id‚üßR : ‚àÄ {X} ‚Üí X ===> X
‚ü¶id‚üßR .left x = x
‚ü¶id‚üßR .right .mor x = x
‚ü¶id‚üßR .rel-mor w x‚ÇÅ x‚ÇÇ r = r

------------------------------------------------------------------------------
-- Products and terminal object
‚ü¶‚ä§‚üßR : WRel
‚ü¶‚ä§‚üßR .Left = ‚ä§
‚ü¶‚ä§‚üßR .Right = K ‚ä§
‚ü¶‚ä§‚üßR .rel w tt tt = ‚ä§
‚ü¶‚ä§‚üßR .ext œÅ tt tt tt = tt

‚ü¶terminal‚üßR : ‚àÄ {X} ‚Üí X ===> ‚ü¶‚ä§‚üßR
‚ü¶terminal‚üßR .left _ = tt
‚ü¶terminal‚üßR .right .mor _ = tt
‚ü¶terminal‚üßR .rel-mor _ _ _ _ = tt

_‚ü¶√ó‚üßR_ : WRel ‚Üí WRel ‚Üí WRel
(X ‚ü¶√ó‚üßR Y) .Left = X .Left √ó Y .Left
(X ‚ü¶√ó‚üßR Y) .Right = X .Right ‚ü¶√ó‚üß Y .Right
(X ‚ü¶√ó‚üßR Y) .rel w (x , y) (x' , y') = X .rel w x x' √ó Y .rel w y y'
(X ‚ü¶√ó‚üßR Y) .ext œÅ (x , y) (x' , y') (r‚ÇÅ , r‚ÇÇ) =
  (X .ext œÅ x x' r‚ÇÅ) , (Y .ext œÅ y y' r‚ÇÇ)

‚ü®_,_‚ü©R : ‚àÄ {X Y Z} ‚Üí (X ===> Y) ‚Üí (X ===> Z) ‚Üí (X ===> (Y ‚ü¶√ó‚üßR Z))
‚ü® f , g ‚ü©R .left x = (f .left x) , (g .left x)
‚ü® f , g ‚ü©R .right .mor x = (f .right .mor x) , (g .right .mor x)
‚ü® f , g ‚ü©R .rel-mor w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ =
  f .rel-mor w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ ,
  g .rel-mor w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ

‚ü¶proj‚ÇÅ‚üßR : ‚àÄ {X Y} ‚Üí (X ‚ü¶√ó‚üßR Y) ===> X
‚ü¶proj‚ÇÅ‚üßR .left = proj‚ÇÅ
‚ü¶proj‚ÇÅ‚üßR .right = ‚ü¶proj‚ÇÅ‚üß
‚ü¶proj‚ÇÅ‚üßR .rel-mor w _ _ r = r .proj‚ÇÅ

‚ü¶proj‚ÇÇ‚üßR : ‚àÄ {X Y} ‚Üí (X ‚ü¶√ó‚üßR Y) ===> Y
‚ü¶proj‚ÇÇ‚üßR .left = proj‚ÇÇ
‚ü¶proj‚ÇÇ‚üßR .right = ‚ü¶proj‚ÇÇ‚üß
‚ü¶proj‚ÇÇ‚üßR .rel-mor w _ _ r = r .proj‚ÇÇ

------------------------------------------------------------------------------
-- Functions and Universal Quantification

-- FIXME: disconnect functions and forall from LiftMR; make the
-- parameterised semantics put them together
_‚ü¶‚áí‚üßR_ : WRel ‚Üí WRel ‚Üí WRel
(X ‚ü¶‚áí‚üßR Y) .Left = X .Left ‚Üí Y .Left
(X ‚ü¶‚áí‚üßR Y) .Right = X .Right ‚ü¶‚áí‚üß Y .Right
(X ‚ü¶‚áí‚üßR Y) .rel w f g =
  ‚àÄ w' (œÅ : w' ‚áíw w) x y ‚Üí
     X .rel w' x y ‚Üí
     Y .rel w' (f x) (g (w' .ctxt) (œÅ .ren) y)
(X ‚ü¶‚áí‚üßR Y) .ext œÅ f g r =
  Œª w'' œÅ' x y ‚Üí r w'' (œÅ ‚àòw œÅ') x y

‚ü¶Œõ‚üßR : ‚àÄ {X Y Z} ‚Üí ((X ‚ü¶√ó‚üßR Y) ===> Z) ‚Üí (X ===> (Y ‚ü¶‚áí‚üßR Z))
‚ü¶Œõ‚üßR {X} f .left x y = f .left (x , y)
‚ü¶Œõ‚üßR {X} f .right = ‚ü¶Œõ‚üß (f .right)
‚ü¶Œõ‚üßR {X} f .rel-mor w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ w' œÅ y‚ÇÅ y‚ÇÇ r-y‚ÇÅy‚ÇÇ =
  f .rel-mor w' (x‚ÇÅ , y‚ÇÅ)
                (X .Right .rename (œÅ .ren) x‚ÇÇ , y‚ÇÇ)
                (X .ext œÅ x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ , r-y‚ÇÅy‚ÇÇ)

‚ü¶eval‚üßR : ‚àÄ {X Y} ‚Üí ((X ‚ü¶‚áí‚üßR Y) ‚ü¶√ó‚üßR X) ===> Y
‚ü¶eval‚üßR .left (f , x) = f x
‚ü¶eval‚üßR .right = ‚ü¶eval‚üß
‚ü¶eval‚üßR .rel-mor w (f‚ÇÅ , x‚ÇÅ) (f‚ÇÇ , x‚ÇÇ) (r-f‚ÇÅf‚ÇÇ , r-x‚ÇÅx‚ÇÇ) =
  r-f‚ÇÅf‚ÇÇ w id-w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ

‚ü¶‚àÄ‚üßR : (‚Ñï ‚Üí WRel) ‚Üí WRel
‚ü¶‚àÄ‚üßR A .Left = ‚àÄ n ‚Üí A n .Left
‚ü¶‚àÄ‚üßR A .Right = ‚ü¶‚àÄ‚üß (Œª n ‚Üí A n .Right)
‚ü¶‚àÄ‚üßR A .rel w x y = ‚àÄ n ‚Üí A n .rel w (x n) (y n)
‚ü¶‚àÄ‚üßR A .ext œÅ x y r n = A n .ext œÅ (x n) (y n) (r n)

‚ü¶‚àÄ-intro‚üßR : ‚àÄ {X A} ‚Üí (‚àÄ n ‚Üí X ===> A n) ‚Üí X ===> ‚ü¶‚àÄ‚üßR A
‚ü¶‚àÄ-intro‚üßR f .left x n = f n .left x
‚ü¶‚àÄ-intro‚üßR f .right = ‚ü¶‚àÄ-intro‚üß (Œª n ‚Üí f n .right)
‚ü¶‚àÄ-intro‚üßR f .rel-mor w x‚ÇÅ x‚ÇÇ r n = f n .rel-mor w x‚ÇÅ x‚ÇÇ r

‚ü¶‚àÄ-elim‚üßR : ‚àÄ {A} n ‚Üí ‚ü¶‚àÄ‚üßR A ===> A n
‚ü¶‚àÄ-elim‚üßR n .left f = f n
‚ü¶‚àÄ-elim‚üßR n .right = ‚ü¶‚àÄ-elim‚üß n
‚ü¶‚àÄ-elim‚üßR n .rel-mor w f‚ÇÅ f‚ÇÇ r = r n

------------------------------------------------------------------------------
KR : Set ‚Üí WRel
KR X .Left = X
KR X .Right = K X
KR X .rel w = _‚â°_
KR X .ext œÅ x y eq = eq

‚ü¶Index‚üßR : ‚Ñï ‚Üí WRel
‚ü¶Index‚üßR n = KR (Fin n)

module _ (extFunc : ‚Ñö ‚Üí ‚Ñö) where

  ext-evalLinExp :
    ‚àÄ {w‚ÇÅ w‚ÇÇ} e (œÅ : w‚ÇÇ ‚áíw w‚ÇÅ) ‚Üí
      eval-LinExp e (w‚ÇÅ .env) ‚â° eval-LinExp (rename-LinExp (œÅ .ren) e) (w‚ÇÇ .env)
  ext-evalLinExp (const q)   œÅ = refl
  ext-evalLinExp (var q x)   œÅ = cong (Œª ‚ñ° ‚Üí q * ‚ñ°) (sym (œÅ .presv x))
  ext-evalLinExp (e‚ÇÅ `+` e‚ÇÇ) œÅ = cong‚ÇÇ _+_ (ext-evalLinExp e‚ÇÅ œÅ) (ext-evalLinExp e‚ÇÇ œÅ)

  ext-evalConstraint :
    ‚àÄ {w‚ÇÅ w‚ÇÇ} p (œÅ : w‚ÇÇ ‚áíw w‚ÇÅ) ‚Üí
      eval-ConstraintExp extFunc p (w‚ÇÅ .env)
      ‚â° eval-ConstraintExp extFunc (rename-ConstraintExp (œÅ .ren) p) (w‚ÇÇ .env)
  ext-evalConstraint (e‚ÇÅ `‚â§` e‚ÇÇ) œÅ rewrite ext-evalLinExp e‚ÇÅ œÅ rewrite ext-evalLinExp e‚ÇÇ œÅ = refl
  ext-evalConstraint (e‚ÇÅ `>` e‚ÇÇ) œÅ rewrite ext-evalLinExp e‚ÇÅ œÅ rewrite ext-evalLinExp e‚ÇÇ œÅ = refl
  ext-evalConstraint (e‚ÇÅ `=` e‚ÇÇ) œÅ rewrite ext-evalLinExp e‚ÇÅ œÅ rewrite ext-evalLinExp e‚ÇÇ œÅ = refl
  ext-evalConstraint (e‚ÇÅ `‚â†` e‚ÇÇ) œÅ rewrite ext-evalLinExp e‚ÇÅ œÅ rewrite ext-evalLinExp e‚ÇÇ œÅ = refl
  ext-evalConstraint (p and q)   œÅ rewrite ext-evalConstraint p œÅ rewrite ext-evalConstraint q œÅ = refl
  ext-evalConstraint (p or q)    œÅ rewrite ext-evalConstraint p œÅ rewrite ext-evalConstraint q œÅ = refl
  ext-evalConstraint (x `=`f y)  œÅ rewrite œÅ .presv x rewrite œÅ .presv y = refl
  ext-evalConstraint (x `‚â†`f y)  œÅ rewrite œÅ .presv x rewrite œÅ .presv y = refl

  ------------------------------------------------------------------------------
  -- Numbers, and linear expressions
  ‚ü¶Num‚üßR : Linearity ‚Üí WRel
  ‚ü¶Num‚üßR const = KR ‚Ñö
  ‚ü¶Num‚üßR linear .Left = ‚Ñö
  ‚ü¶Num‚üßR linear .Right = ‚ü¶Num‚üß linear
  ‚ü¶Num‚üßR linear .rel w x exp = x ‚â° eval-LinExp exp (w .env)
  ‚ü¶Num‚üßR linear .ext œÅ x exp eq = trans eq (ext-evalLinExp exp œÅ)

  ‚ü¶num‚üßR : ‚àÄ {X} ‚Üí ‚Ñö ‚Üí X ===> ‚ü¶Num‚üßR const
  ‚ü¶num‚üßR q .left _ = q
  ‚ü¶num‚üßR q .right = ‚ü¶num‚üß q
  ‚ü¶num‚üßR q .rel-mor w _ _ _ = refl

  ‚ü¶add‚üßR : (‚ü¶Num‚üßR linear ‚ü¶√ó‚üßR ‚ü¶Num‚üßR linear) ===> ‚ü¶Num‚üßR linear
  ‚ü¶add‚üßR .left (x , y) = x + y
  ‚ü¶add‚üßR .right = ‚ü¶add‚üß
  ‚ü¶add‚üßR .rel-mor w (x‚ÇÅ , y‚ÇÅ) (x‚ÇÇ , y‚ÇÇ) (r-x‚ÇÅx‚ÇÇ , r-y‚ÇÅy‚ÇÇ) = cong‚ÇÇ _+_ r-x‚ÇÅx‚ÇÇ r-y‚ÇÅy‚ÇÇ

  ‚ü¶mul‚üßR : (‚ü¶Num‚üßR const ‚ü¶√ó‚üßR ‚ü¶Num‚üßR linear) ===> ‚ü¶Num‚üßR linear
  ‚ü¶mul‚üßR .left (x , y) = x * y
  ‚ü¶mul‚üßR .right = ‚ü¶mul‚üß
  ‚ü¶mul‚üßR .rel-mor w (x‚ÇÅ , y‚ÇÅ) (x‚ÇÇ , y‚ÇÇ) (r-x‚ÇÅx‚ÇÇ , r-y‚ÇÅy‚ÇÇ) =
    trans (cong‚ÇÇ _*_ r-x‚ÇÅx‚ÇÇ r-y‚ÇÅy‚ÇÇ) (eval-‚äõ x‚ÇÇ y‚ÇÇ (w .env))

  ‚ü¶const‚üßR : ‚ü¶Num‚üßR const ===> ‚ü¶Num‚üßR linear
  ‚ü¶const‚üßR .left q = q
  ‚ü¶const‚üßR .right = ‚ü¶const‚üß
  ‚ü¶const‚üßR .rel-mor w _ _ eq = eq

  ------------------------------------------------------------------------------
  -- Booleans and constraints
  ‚ü¶Bool‚üßR : BoolKind ‚Üí WRel
  ‚ü¶Bool‚üßR constraint .Left = ùîπ
  ‚ü¶Bool‚üßR constraint .Right = ‚ü¶Bool‚üß constraint
  ‚ü¶Bool‚üßR constraint .rel w b œï = b ‚â° eval-ConstraintExp extFunc œï (w .env)
  ‚ü¶Bool‚üßR constraint .ext œÅ b œï eq = trans eq (ext-evalConstraint œï œÅ)

  ‚ü¶‚â§‚üßR : (‚ü¶Num‚üßR linear ‚ü¶√ó‚üßR ‚ü¶Num‚üßR linear) ===> ‚ü¶Bool‚üßR constraint
  ‚ü¶‚â§‚üßR .left (x , y) = x ‚â§·µá y
  ‚ü¶‚â§‚üßR .right        = ‚ü¶‚â§‚üß
  ‚ü¶‚â§‚üßR .rel-mor w (x‚ÇÅ , y‚ÇÅ) (x‚ÇÇ , y‚ÇÇ) (r-x‚ÇÅx‚ÇÇ , r-y‚ÇÅy‚ÇÇ) =
    cong‚ÇÇ _‚â§·µá_ r-x‚ÇÅx‚ÇÇ r-y‚ÇÅy‚ÇÇ

  ‚ü¶and‚üßR : (‚ü¶Bool‚üßR constraint ‚ü¶√ó‚üßR ‚ü¶Bool‚üßR constraint) ===> ‚ü¶Bool‚üßR constraint
  ‚ü¶and‚üßR .left (x , y) = x ‚àß y
  ‚ü¶and‚üßR .right = ‚ü¶and‚üß
  ‚ü¶and‚üßR .rel-mor w (x‚ÇÅ , y‚ÇÅ) (x‚ÇÇ , y‚ÇÇ) (r-x‚ÇÅx‚ÇÇ , r-y‚ÇÅy‚ÇÇ) =
    cong‚ÇÇ _‚àß_ r-x‚ÇÅx‚ÇÇ r-y‚ÇÅy‚ÇÇ

  ‚ü¶or‚üßR : (‚ü¶Bool‚üßR constraint ‚ü¶√ó‚üßR ‚ü¶Bool‚üßR constraint) ===> ‚ü¶Bool‚üßR constraint
  ‚ü¶or‚üßR .left (x , y) = x ‚à® y
  ‚ü¶or‚üßR .right = ‚ü¶or‚üß
  ‚ü¶or‚üßR .rel-mor w (x‚ÇÅ , y‚ÇÅ) (x‚ÇÇ , y‚ÇÇ) (r-x‚ÇÅx‚ÇÇ , r-y‚ÇÅy‚ÇÇ) =
    cong‚ÇÇ _‚à®_ r-x‚ÇÅx‚ÇÇ r-y‚ÇÅy‚ÇÇ

  ‚ü¶not‚üßR : ‚ü¶Bool‚üßR constraint ===> ‚ü¶Bool‚üßR constraint
  ‚ü¶not‚üßR .left = not
  ‚ü¶not‚üßR .right = ‚ü¶not‚üß
  ‚ü¶not‚üßR .rel-mor w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ =
    trans (cong not r-x‚ÇÅx‚ÇÇ) (eval-negate extFunc x‚ÇÇ (w .env))

  ------------------------------------------------------------------------------
  module _ (X : WRel) where

    LetLiftR : (w : World) ‚Üí X .Left ‚Üí LetLift (X .Right .Carrier) (w .ctxt) ‚Üí Set
    LetLiftR w a (return b) = X .rel w a b
    LetLiftR w a (if c k‚ÇÅ k‚ÇÇ) =
      if·µá (eval-ConstraintExp extFunc c (w .env))
       then LetLiftR w a k‚ÇÅ
       else LetLiftR w a k‚ÇÇ
    LetLiftR w a (let-linexp e k) =
      LetLiftR (extend-w w (eval-LinExp e (w .env))) a k
    LetLiftR w a (let-funexp x k) =
      LetLiftR (extend-w w (extFunc (w .env x))) a k

    ext-lift : ‚àÄ {w‚ÇÅ w‚ÇÇ} (œÅ : w‚ÇÇ ‚áíw w‚ÇÅ) la lb ‚Üí
               LetLiftR w‚ÇÅ la lb ‚Üí
               LetLiftR w‚ÇÇ la (rename-lift (X .Right .rename) (œÅ .ren) lb)
    ext-lift œÅ a (return b) = X .ext œÅ a b
    ext-lift {w‚ÇÅ} œÅ a (if c tru fal) rewrite sym (ext-evalConstraint c œÅ) with eval-ConstraintExp extFunc c (w‚ÇÅ .env)
    ... | false = ext-lift œÅ a fal
    ... | true  = ext-lift œÅ a tru
    ext-lift œÅ a (let-linexp x lb) =
      ext-lift (record { ren = NormalisedExpr.under (œÅ .ren)
                       ; presv = Œª { zero ‚Üí sym (ext-evalLinExp x œÅ)
                                   ; (succ x‚ÇÅ) ‚Üí œÅ .presv x‚ÇÅ } }) a lb
    ext-lift œÅ a (let-funexp x lb) =
      ext-lift (record { ren = NormalisedExpr.under (œÅ .ren)
                       ; presv = Œª { zero ‚Üí cong extFunc (œÅ .presv x)
                                   ; (succ x‚ÇÅ) ‚Üí œÅ .presv x‚ÇÅ } }) a lb

    LiftMR : WRel
    LiftMR .Left = X .Left
    LiftMR .Right = LiftM (X .Right)
    LiftMR .rel = LetLiftR
    LiftMR .ext = ext-lift

  let-bindR : ‚àÄ {X Y} w x y ‚Üí
    (f : X .Left ‚Üí Y .Left)
    (g : (X .Right .Carrier ‚áí‚Çñ LetLift (Y .Right .Carrier)) (w .ctxt)) ‚Üí
    LetLiftR X w x y ‚Üí
    (‚àÄ w' (œÅ : w' ‚áíw w) a b ‚Üí X .rel w' a b ‚Üí LetLiftR Y w' (f a) (g (w' .ctxt) (œÅ .ren) b)) ‚Üí
    LetLiftR Y w (f x) (bind-let y g)
  let-bindR w x‚ÇÅ (return x‚ÇÇ) f g r-x‚ÇÅx‚ÇÇ r-fg = r-fg w id-w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ
  let-bindR w x‚ÇÅ (if c x‚ÇÇ‚ÇÅ x‚ÇÇ‚ÇÇ) f g r-x‚ÇÅx‚ÇÇ r-fg with eval-ConstraintExp extFunc c (w .env)
  ... | true = let-bindR w x‚ÇÅ x‚ÇÇ‚ÇÅ f g r-x‚ÇÅx‚ÇÇ r-fg
  ... | false = let-bindR w x‚ÇÅ x‚ÇÇ‚ÇÇ f g r-x‚ÇÅx‚ÇÇ r-fg
  let-bindR w x‚ÇÅ (let-linexp e x‚ÇÇ) f g r-x‚ÇÅx‚ÇÇ r-fg =
    let-bindR (extend-w w (eval-LinExp e (w .env)))
       x‚ÇÅ x‚ÇÇ f (Œª Œî' œÅ ‚Üí g Œî' (wk-r ‚àò œÅ))
       r-x‚ÇÅx‚ÇÇ
       Œª w' œÅ ‚Üí r-fg w' (wk-w ‚àòw œÅ)
  let-bindR w x‚ÇÅ (let-funexp v x‚ÇÇ) f g r-x‚ÇÅx‚ÇÇ r-fg =
    let-bindR (extend-w w (extFunc (w .env v)))
       x‚ÇÅ x‚ÇÇ f (Œª Œî' œÅ ‚Üí g Œî' (wk-r ‚àò œÅ))
       r-x‚ÇÅx‚ÇÇ
       Œª w' œÅ ‚Üí r-fg w' (wk-w ‚àòw œÅ)

  ‚ü¶return‚üßR : ‚àÄ {X} ‚Üí X ===> LiftMR X
  ‚ü¶return‚üßR .left = Œª x ‚Üí x
  ‚ü¶return‚üßR .right .mor = return
  ‚ü¶return‚üßR .rel-mor w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ = r-x‚ÇÅx‚ÇÇ

  ‚ü¶extFunc‚üßR : ‚ü¶Num‚üßR linear ===> LiftMR (‚ü¶Num‚üßR linear)
  ‚ü¶extFunc‚üßR .left = extFunc
  ‚ü¶extFunc‚üßR .right = ‚ü¶extFunc‚üß
  ‚ü¶extFunc‚üßR .rel-mor w x‚ÇÅ x‚ÇÇ r-x‚ÇÅx‚ÇÇ =
    trans (cong extFunc r-x‚ÇÅx‚ÇÇ) (sym (*-identityÀ° _))

  ‚ü¶if‚üßR : ‚àÄ {X} ‚Üí ((LiftMR X ‚ü¶√ó‚üßR LiftMR X) ‚ü¶√ó‚üßR ‚ü¶Bool‚üßR constraint) ===> LiftMR X
  ‚ü¶if‚üßR .left ((tr , fa) , false) = fa
  ‚ü¶if‚üßR .left ((tr , fa) , true) = tr
  ‚ü¶if‚üßR .right .mor ((tr , fa) , œï)= if œï tr fa
  ‚ü¶if‚üßR .rel-mor w ((tr‚ÇÅ , fa‚ÇÅ) , false) ((tr‚ÇÇ , fa‚ÇÇ) , œï) ((tr‚ÇÅ-tr‚ÇÇ , fa‚ÇÅ-fa‚ÇÇ) , eq) rewrite sym eq = fa‚ÇÅ-fa‚ÇÇ
  ‚ü¶if‚üßR .rel-mor w ((tr‚ÇÅ , fa‚ÇÅ) , true) ((tr‚ÇÇ , fa‚ÇÇ) , œï) ((tr‚ÇÅ-tr‚ÇÇ , fa‚ÇÅ-fa‚ÇÇ) , eq) rewrite sym eq = tr‚ÇÅ-tr‚ÇÇ

  extendR : ‚àÄ {X Y Z} ‚Üí ((X ‚ü¶√ó‚üßR Y) ===> LiftMR Z) ‚Üí (X ‚ü¶√ó‚üßR LiftMR Y) ===> LiftMR Z
  extendR f .left = f .left
  extendR {X} f .right .mor (x , ly) =
    bind-let ly (Œª Œî' œÅ y ‚Üí f .right .mor (X .Right .rename œÅ x , y))
  extendR {X} f .rel-mor w (x‚ÇÅ , ly‚ÇÅ) (x‚ÇÇ , ly‚ÇÇ) (x‚ÇÅx‚ÇÇ , ly‚ÇÅ-ly‚ÇÇ) =
    let-bindR w ly‚ÇÅ ly‚ÇÇ
      (Œª y ‚Üí f .left (x‚ÇÅ , y))
      (Œª Œî' œÅ y ‚Üí f .right .mor (X .Right .rename œÅ x‚ÇÇ , y))
      ly‚ÇÅ-ly‚ÇÇ
      Œª w' œÅ y‚ÇÅ y‚ÇÇ y‚ÇÅy‚ÇÇ ‚Üí
        f .rel-mor w' (x‚ÇÅ , y‚ÇÅ) (X .Right .rename (œÅ .ren) x‚ÇÇ , y‚ÇÇ) (X .ext œÅ x‚ÇÅ x‚ÇÇ x‚ÇÅx‚ÇÇ , y‚ÇÅy‚ÇÇ)

  -- unaryMR : ‚àÄ {X Y} ‚Üí (X ===> LiftMR Y) ‚Üí LiftMR X ===> LiftMR Y
  -- unaryMR f = extendR (f ‚àòR ‚ü¶proj‚ÇÇ‚üßR) ‚àòR ‚ü® ‚ü¶terminal‚üßR , ‚ü¶id‚üßR ‚ü©R

  -- binaryMR : ‚àÄ {X Y Z} ‚Üí ((X ‚ü¶√ó‚üßR Y) ===> LiftMR Z) ‚Üí (LiftMR X ‚ü¶√ó‚üßR LiftMR Y) ===> LiftMR Z
  -- binaryMR f =
  --   extendR (extendR (f ‚àòR ‚ü® ‚ü¶proj‚ÇÇ‚üßR , ‚ü¶proj‚ÇÅ‚üßR ‚ü©R) ‚àòR ‚ü® ‚ü¶proj‚ÇÇ‚üßR , ‚ü¶proj‚ÇÅ‚üßR ‚ü©R)

  open import Interpretation

  module _ where
    open Model

    ‚Ñ≥ : Model (suc 0‚Ñì) 0‚Ñì
    ‚Ñ≥ .‚ü¶Type‚üß = WRel
    ‚Ñ≥ .Model._==>_ = _===>_
    ‚Ñ≥ .Model.‚ü¶id‚üß = ‚ü¶id‚üßR
    ‚Ñ≥ .Model._‚àò_ = _‚àòR_
    ‚Ñ≥ .Model._‚ü¶√ó‚üß_ = _‚ü¶√ó‚üßR_
    ‚Ñ≥ .Model.‚ü¶‚ä§‚üß = ‚ü¶‚ä§‚üßR
    ‚Ñ≥ .Model.‚ü¶terminal‚üß = ‚ü¶terminal‚üßR
    ‚Ñ≥ .Model.‚ü¶proj‚ÇÅ‚üß = ‚ü¶proj‚ÇÅ‚üßR
    ‚Ñ≥ .Model.‚ü¶proj‚ÇÇ‚üß = ‚ü¶proj‚ÇÇ‚üßR
    ‚Ñ≥ .Model.‚ü®_,_‚ü© = ‚ü®_,_‚ü©R
    ‚Ñ≥ .Model._‚ü¶‚áí‚üß_ = _‚ü¶‚áí‚üßR_
    ‚Ñ≥ .Model.‚ü¶Œõ‚üß = ‚ü¶Œõ‚üßR
    ‚Ñ≥ .Model.‚ü¶eval‚üß = ‚ü¶eval‚üßR
    ‚Ñ≥ .Model.‚ü¶‚àÄ‚üß = ‚ü¶‚àÄ‚üßR
    ‚Ñ≥ .Model.‚ü¶‚àÄ-intro‚üß = ‚ü¶‚àÄ-intro‚üßR
    ‚Ñ≥ .Model.‚ü¶‚àÄ-elim‚üß = ‚ü¶‚àÄ-elim‚üßR
    ‚Ñ≥ .Mon = LiftMR
    ‚Ñ≥ .Model.‚ü¶return‚üß = ‚ü¶return‚üßR
    ‚Ñ≥ .‚ü¶extend‚üß = extendR
    ‚Ñ≥ .Model.‚ü¶Num‚üß = ‚ü¶Num‚üßR
    ‚Ñ≥ .Model.‚ü¶add‚üß = ‚ü¶add‚üßR
    ‚Ñ≥ .Model.‚ü¶mul‚üß = ‚ü¶mul‚üßR
    ‚Ñ≥ .Model.‚ü¶num‚üß = ‚ü¶num‚üßR
    ‚Ñ≥ .Model.‚ü¶const‚üß = ‚ü¶const‚üßR
    ‚Ñ≥ .Model.‚ü¶extFunc‚üß = ‚ü¶extFunc‚üßR
    ‚Ñ≥ .Model.‚ü¶Bool‚üß = ‚ü¶Bool‚üßR
    ‚Ñ≥ .Model.‚ü¶not‚üß = ‚ü¶not‚üßR
    ‚Ñ≥ .Model.‚ü¶and‚üß = ‚ü¶and‚üßR
    ‚Ñ≥ .Model.‚ü¶or‚üß = ‚ü¶or‚üßR
    ‚Ñ≥ .Model.‚ü¶‚â§‚üß = ‚ü¶‚â§‚üßR
    ‚Ñ≥ .Model.‚ü¶if‚üß = ‚ü¶if‚üßR
    ‚Ñ≥ .‚ü¶Index‚üß = ‚ü¶Index‚üßR
    ‚Ñ≥ .‚ü¶idx‚üß n i .left = Œª x ‚Üí i
    ‚Ñ≥ .‚ü¶idx‚üß n i .right .mor x = i
    ‚Ñ≥ .‚ü¶idx‚üß n i .rel-mor w _ _ _ = refl

  module ‚Ñê = Interpret ‚Ñ≥

  standard : Œµ / Œµ ‚ä¢ Bool constraint ‚Üí ùîπ
  standard t = ‚Ñê.‚ü¶ t ‚üßtm tt .left tt

  normalise2 : Œµ / Œµ ‚ä¢ Bool constraint ‚Üí Ex ConstraintExp Œµ
  normalise2 t =
    expand (bind-let (‚Ñê.‚ü¶ t ‚üßtm tt .right .mor tt) Œª Œî' œÅ c ‚Üí return (return c)) (Œª x ‚Üí x)
